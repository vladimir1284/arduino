#include "SR04.h"

SR04::SR04()
{

}

void SR04::run()
{
  int i;
  for (i = 0; i < nSensors; i++)
  {
    if (newValue[i] != 0)
    {
      mf[i].insertValue(newValue[i]);
      newValue[i] = 0;
    }
  }
}

int SR04::getDistance(int sensor)
{
  // Convert pulsewidth to distance (cm)
  //return mf[sensor].getValue() / 58;
  return newValue[sensor] / 58;
}

void SR04::begin()
{
  int i;
  // Set up the trigger
  pinMode(triggerPin, OUTPUT);

  // Pause the timer 3 while we're configuring it
  Timer3.pause();

  // Set up an interrupt on channel 1
  Timer3.setChannel1Mode(TIMER_OUTPUT_COMPARE);
  Timer3.setCompare(TIMER_CH1, PULSEWIDTH);  // Interrupt 10 count after each update
  Timer3.setPrescaleFactor(PRESCALER_VALUE); // 1MHz
  Timer3.setOverflow(OVERFLOW_VALUE);
  Timer3.attachCompare1Interrupt(handler_trigger_off); // When compare
  Timer3.attachInterrupt(0, handler_trigger_on);       // When over flow
  Timer3.refresh();

  // Start the timer counting
  Timer3.resume();

  // Set up echo sensorPins
  for (i = 0; i < nSensors; i++)
  {
    pinMode(SENSOR_PINS[i], INPUT);
    attachInterrupt(SENSOR_PINS[i], exti_handler, CHANGE);
    lastVal[i] = 0;
    newValue[i] = 0;
  }
}

void SR04::handler_trigger_on()
{
  digitalWrite(triggerPin, HIGH);
}

void SR04::handler_trigger_off()
{
  digitalWrite(triggerPin, LOW);
}

void SR04::exti_handler()
{
  int i, val;

  Timer3.pause();

  for (i = 0; i < nSensors; i++)
  {
    val = digitalRead(SENSOR_PINS[i]);
    if (lastVal[i] != val)
    { // This is the relevant pin
      lastVal[i] = val;
      if (val == HIGH)
      {
        oldCount[i] = Timer3.getCount();
      }
      else
      {
        // Store new value
        newValue[i] = Timer3.getCount() - oldCount[i];
      }
    }
  }
  Timer3.resume();
}
